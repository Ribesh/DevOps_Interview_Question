## Q1: What best practices do you follow for Terraform code organization?

### Answer:
- Modular structure and code reusablability using `modules`
- **State file management** 
    -   remote backends, 
    -   locking, 
    -   versioning
- **Version control (Git)** with code review process
- **Documentation** (README, variable descriptions, outputs)
- Variable validation and sensible defaults
- Separate variables, outputs, and main.tf files
- Use of workspaces for environment separation



## Q2: Design a multi-environment infrastructure using Terraform
**Scenario:** You need dev, staging, and production environments with different configurations.

### Answer:
**Expected approach:**
- Use workspaces or separate state files per environment
   ```sh
   terraform workspace show   #Show Current Working Workspace
   terraform workspace new dev   #Create New Workspace dev
   terraform workspace list   #List all the Workspaces
   terraform workspace select dev #Switch to the dev Workspace
   ```
- Environment-specific variable files (`dev.tfvars`, `staging.tfvars`, `prod.tfvars`)
- Terraform modules for code reuse
- Separate AWS accounts for prod isolation (best practice)
- Example structure:
  ```
  terraform/
  ├── modules/
  │   ├── networking/
  │   ├── compute/
  │   └── databases/
  ├── environments/
  │   ├── dev/
  │   ├── staging/
  │   └── prod/
  └── shared/
  ```

**Follow-up:** "How would you prevent accidental production changes?"
- Answer should include: plan reviews, separate approval workflows, infrastructure-as-code review process (merge request approvals)


## Q3: Explain Terraform state management. What challenges have you encountered?
**Why ask:** Critical for production Terraform usage; tests real-world experience.

### Answer: 
**Expected knowledge:**
- State file stores current infrastructure configuration
- Remote backends (S3, Terraform Cloud) prevent concurrent modifications
- State locking prevents race conditions
- Sensitive data management

**Challenges to discuss:**
- "State file corruption after failed apply—resolved by using remote backend with versioning"
- "Team members accidentally running terraform apply simultaneously—fixed by implementing state locking with DynamoDB"
- "Secrets in state files—mitigated using AWS Secrets Manager and careful variable handling"

**Ideal depth:** Real scenario from experience, not just textbook knowledge.

## Q4: Compare Terraform, Ansible, and CloudFormation. When would you use each?
**Why ask:** Tests knowledge of different IaC tools and decision-making capability.

### Answer:
**Expected comparison:**

| Tool | Best For | Approach | Pros | Cons |
|------|----------|----------|------|------|
| **Terraform** | Multi-cloud, modular infrastructure | Declarative | Cloud-agnostic, state management, modules | State file complexity, provider limitations |
| **Ansible** | Configuration management, application deployment | Procedural | Agentless, simple YAML, idempotent | Slower for large-scale infra changes |
| **CloudFormation** | AWS-specific infrastructure | Declarative | Native AWS integration, compliance tracking | AWS-only, verbose syntax |

**Strong answer:** "I'd use Terraform for infrastructure provisioning across AWS and Azure, Ansible for post-deployment configuration and software installation, and CloudFormation for AWS-specific resources integrated with IAM policies and compliance requirements."

