# Kubernetes Architecture

## Q. Explain the Kubernetes Architecute

- Kubernetes is divided into 2 components
    1. Control Plane
    2. Data Plane  

 OR

- 1. Master Plane
    2. Control Plane

---

## Master Plane consists of below Components

1. API Server
2. ETCD
3. Scheduler
4. Controller Manager


## Data Plane Components
1. Kubelet
2. Container-Run Time
3. Kube-Proxy

---

### 1. API Server
-   It is the **main components of Kubernetes**, where kubernetes endpoint is exposed

-   Any request we create is initially server by the `API Server`
    -   Eg: Creating a Deployment, Pods, Resources

#### Steps:
1.  `API Server` talks with `Scheduler Components` to identify the right node
    -   There can be multiple workers nodes, so `Scheduler` tried to identify the right node..... i.e which nodes is right node for your pod
    -   Since your `Pod definition` file, might have some **tolerations**.


2. Once the decision is taken to identify which nodes the pod should live in
    -   `API Server` then goes and forwards the request/information to `Kubelet`
    -   Kubelet is a part of worker node
    -   If there are **multiple worker nodes**, each nodes has it own `Kubelet` Service running.


3. `Kubelet` forwards/takes help of container run time like *containerd*, *docker-shim*, *crio* ..etc to run the container on the node
    - For example: To run a Java Application, we need a Java Run Time

4. Once a pod is deployed on a node, a `Service` is created and this `Service` is monitored by `Kube-Proxy.`
    - When a `Service` is created, a **Endpoint** is created
    - This **endpoint** is watched by `Kube-Proxy`

5.  `Kube-Proxy` updates the **IP-Tables** to enable routing to the `Pod`

6.  Once the **resource** is created, the information is persisted onto a *key-value data-store* named `ETCD`
    -   All the information of Kubernetes objects are stored in `ETCD` once they are created


7.  Controller Manager
    -   Takes care of running default controllers in Kubernetes such as
        1. Replica Sets
        2. Deployments


#### Steps in brief

-   Imagine a request is initialized by `kubectl` to create a deployment onto Kubernetes

-   Initially, this request is sent to the `API Server`
-   `API Server` performs the **authentication** and **authorization**
-   If the request is valid, it sends the request to the `Scheduler`
-   The `Scheduler` decides on which node the `pod` has to be scheduled
    -   It takes **pod affinity**, **node affinity**, **taint & tolerations** into consideration and defines the right node for the pod

-   Once the `Scheduler` identifies the right node for the pod
-   `API Server` forwards the request to the `Kubelet` on the worker node
-   `Kubelet` invokes the container runtime such as *containerd*, *docker-shim*, *crio* to run the container

-   Then the `API Server` passed the information to `ETCD`